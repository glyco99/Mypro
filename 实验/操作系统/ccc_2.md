## 填空：

1. 当处理器空闲时，调度程序从(**就绪队列)**中选择一个进程分配CPU，而**阻塞**不会分配
2. 分布式系统中死锁分为两类？(**资源死锁和通信死锁)**
3. 从文件的管理角度看，文件有(**文件名**)和(**文件体**)两部分组成。
4. 在段页式存储管理中，每一个程序都有(**段表**)和(**页表**)
5. 进程通常由哪三部分组成？(**pcb，程序段，数据段**)

## 选择：

1. 一般来说为了实现多道设计程序，计算机需要？(**更大的内存**)
2. 在下面的I/O流，需要CPU干扰最少的是？(**通道方式**)
3. 当进程状态转换时，下列哪种进程是不可能发生的？(**阻塞→运行**)
4. 一个进程执行过程中，不可能对应？(**一个进程对应多个PCB**)
5. 进程调度又称低级调度，他的任务是？(**从就绪队列中选择一个进程参与调度**)
6. 如果允许不同用户的文件具有相同的文件名，通常采用什么？(**多级目录结构**)
7. 文件控制块不包括？(磁盘坏块信息)
8. 为了提高设备分配的灵活性，用户应指定？(**设备类相对号**)
9. 产生进程死锁的原因，可能有？(**多个进程竞争**)
10. 文件系统中用什么管理文件？(**目录**)

## 名词解释

### 什么是缺页中断？

​	当作业所访问某页时，到页表中去查找，若该页不在内存时，产生缺页中断。缺页中断是一种特殊的中断，与一般的中断相比，其主要区别为产生的中断时间不一样，缺页中断是在指令执行过程中产生中断请求；产生中断的次数不一样：缺页中断在一条指令执行期间就可以产生多次中断。

### 什么是临界区？

​	作为临界资源，不论是硬件临界资源，还是软件临界资源，多个并发进程都必须互斥地访问或使用，每个进程中访问临界资源的那段代码称为临界区。

###　什么是独占设备？

​	 在一定时间段内只允许一个用户（进程）访问的设备。系统一旦把这种设备分配给一个进程后，便由该进程独占，直到用完释放，其他进程才能使用。

## 简答：

### 请说明死锁的防止和死锁避免的区别？

1. **死锁的防止是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现**
2. **而死锁避免则不那么严格限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁，死锁避免是在系统运行过程中注意避免死锁的最终发生。**

### 什么是文件的物理结构？物理结构有哪几种？
  	文件的物理结构又称文件的存储结构，是指一个文件在外存上的存储组织形式，它与存储介质的存储特性有关。
   物理结构包括顺序结构、链接结构和索引结构

## 计算
### 1.银行家算法？

​	系统中有5个进程P1~P4

| process |              MAX               |          Alloction           |             need              | available  |      |
| :-----: | :----------------------------: | :--------------------------: | :---------------------------: | :--------: | ---- |
|         | A             B             C  | A           B             C  | A             B            C  |            |      |
|   p0    | 10           5              3  | 0           1              0 | 10           4             3  | 3   2    2 |      |
|   p1    | 3            2               2 | 2           0              0 | 1             2             2 |            |      |
|   p2    | 9            0               2 | 3           0              2 | 6             0             0 |            |      |
|   p3    | 2           2                2 | 2           1              1 | 0             1             1 |            |      |
|   p4    | 4           3                3 | 0           0              2 | 4             3             1 |            |      |
|         |                                |                              |                               |            |      |



### 2.在请求分页式中，若M=4，则：

#### FIFO算法：

​	  1			2			3			 4			2			1			  5			6			2			1			2			3				7			6			3			2

|  1   |  1   |  1   |  1   |      |      |  5   |  5   |  5   |  5   |      |  3   |  3   |  3   |      |  3   |
| :--: | :--: | :--: | :--: | ---- | ---- | :--: | :--: | :--: | :--: | ---- | :--: | :--: | :--: | ---- | :--: |
|      |  2   |  2   |  2   |      |      |  2   |  6   |  6   |  6   |      |  6   |  7   |  7   |      |  7   |
|      |      |  3   |  3   |      |      |  3   |  3   |  2   |  2   |      |  2   |  2   |  6   |      |  6   |
|      |      |      |  4   |      |      |  4   |  4   |  4   |  1   |      |  1   |  1   |  1   |      |  2   |

​																						缺页率：12/16

#### LRU算法：

​	  1			2			3			 4			2			1			  5			6			2			1			2			3				7			6			3			2

|  1   |  1   |  1   |  1   |      |      |  1   |  1   |      |      |      |  1   |  1   |  6   |      |      |
| :--: | :--: | :--: | :--: | ---- | ---- | :--: | :--: | ---- | ---- | ---- | :--: | :--: | :--: | ---- | ---- |
|      |  2   |  2   |  2   |      |      |  2   |  2   |      |      |      |  2   |  2   |  2   |      |      |
|      |      |  3   |  3   |      |      |  5   |  5   |      |      |      |  3   |  3   |  3   |      |      |
|      |      |      |  4   |      |      |  4   |  6   |      |      |      |  6   |  7   |  7   |      |      |

​																						缺页率：9/16

### PV操作：

设公共汽车上，司机和售票员的活动分别是：
司机的活动： 启动车辆；正常行车；到站停车；
售票员的活动：关车门；售票；开车门；
在汽车不断地到站、停车、行驶过程中，这两个活动有什么同步关系？用信号量和P、V操作实现它们的同步。

解：
在汽车行驶过程中，司机活动与售票员活动之间的同步关系为：售票员关车门后，向司机发开车信号，司机接到开车信号后启动车辆，在汽车正常行驶过程中售票员售票，到站时司机停车，售票员在车停后开车门让乘客上下车。因此司机启动车辆的动作必须与售票员关车门的动作取得同步；售票员开车门的动作也必须与司机停车取得同步，
在本题中，应设置两个信号量：S1、S2。S1表示是否允许司机启动汽车，其初值为0；S2表示是否允许售票员开门，其初值为0。用P、V原语描述如下：

```c
int Sl＝0; int S2＝0;
main()
{ cobegin
driver();
busman();
coend
｝
driver()
{ while(1) {
P(S1);
启动车辆;
正常行车;
到站停车;
V(S2);
｝
｝
busman()
{while(1){
关车门；
V(S1);
售票；
P(S2);
开车门；
上下乘客；
}
}
```


